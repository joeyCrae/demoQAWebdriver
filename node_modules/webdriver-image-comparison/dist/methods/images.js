"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.takeBase64ElementScreenshot = exports.addBlockOuts = exports.saveBase64Image = exports.makeFullPageBase64Image = exports.executeImageCompare = exports.makeCroppedBase64Image = exports.checkBaselineImageExists = void 0;
var fs_extra_1 = require("fs-extra");
var node_path_1 = require("node:path");
var canvas_1 = require("canvas");
var compareImages_js_1 = __importDefault(require("../resemble/compareImages.js"));
var utils_js_1 = require("../helpers/utils.js");
var constants_js_1 = require("../helpers/constants.js");
var rectangles_js_1 = require("./rectangles.js");
var options_interfaces_1 = require("../helpers/options.interfaces");
function checkBaselineImageExists(actualFilePath, baselineFilePath, autoSaveBaseline, logLevel) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2, new Promise(function (resolve, reject) {
                    (0, fs_extra_1.access)(baselineFilePath, function (error) {
                        if (error) {
                            if (autoSaveBaseline) {
                                try {
                                    (0, fs_extra_1.copySync)(actualFilePath, baselineFilePath);
                                    if (logLevel === options_interfaces_1.LogLevel.info) {
                                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n INFO:\n Autosaved the image to\n ".concat(baselineFilePath, "\n#####################################################################################\n"));
                                    }
                                }
                                catch (error) {
                                    reject("\n#####################################################################################\n Image could not be copied. The following error was thrown:\n ".concat(error, "\n#####################################################################################\n"));
                                }
                            }
                            else {
                                reject("\n#####################################################################################\n Baseline image not found, save the actual image manually to the baseline.\n The image can be found here:\n ".concat(actualFilePath, "\n#####################################################################################\n"));
                            }
                        }
                        resolve();
                    });
                })];
        });
    });
}
exports.checkBaselineImageExists = checkBaselineImageExists;
function getRotatedImageIfNeeded(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var _c, screenshotHeight, screenshotWidth, isRotated, _d;
        var isWebDriverElementScreenshot = _b.isWebDriverElementScreenshot, isLandscape = _b.isLandscape, base64Image = _b.base64Image;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    _c = (0, utils_js_1.getScreenshotSize)(base64Image), screenshotHeight = _c.height, screenshotWidth = _c.width;
                    isRotated = !isWebDriverElementScreenshot && isLandscape && screenshotHeight > screenshotWidth;
                    if (!isRotated) return [3, 2];
                    return [4, rotateBase64Image({ base64Image: base64Image, degrees: -90, newHeight: screenshotWidth, newWidth: screenshotHeight })];
                case 1:
                    _d = _e.sent();
                    return [3, 3];
                case 2:
                    _d = base64Image;
                    _e.label = 3;
                case 3: return [2, _d];
            }
        });
    });
}
function logDimensionWarning(_a) {
    var dimension = _a.dimension, logLevel = _a.logLevel, maxDimension = _a.maxDimension, position = _a.position, type = _a.type;
    if (logLevel === options_interfaces_1.LogLevel.debug || logLevel === options_interfaces_1.LogLevel.warn) {
        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n THE RESIZE DIMENSION ".concat(type, "=").concat(dimension, " MADE THE CROPPING GO OUT OF THE SCREEN SIZE\n RESULTING IN A ").concat(type, " CROP POSITION=").concat(position, ".\n THIS HAS BEEN DEFAULTED TO '").concat(['TOP', 'LEFT'].includes(type) ? 0 : maxDimension, "'\n#####################################################################################\n"));
    }
}
function getAdjustedAxis(_a) {
    var length = _a.length, logLevel = _a.logLevel, maxDimension = _a.maxDimension, paddingEnd = _a.paddingEnd, paddingStart = _a.paddingStart, start = _a.start, warningType = _a.warningType;
    var adjustedStart = start - paddingStart;
    var adjustedEnd = start + length + paddingEnd;
    if (adjustedStart < 0) {
        logDimensionWarning({
            dimension: paddingStart,
            logLevel: logLevel,
            maxDimension: maxDimension,
            position: adjustedStart,
            type: warningType === 'WIDTH' ? 'LEFT' : 'TOP',
        });
        adjustedStart = 0;
    }
    if (adjustedEnd > maxDimension) {
        logDimensionWarning({
            dimension: paddingEnd,
            logLevel: logLevel,
            maxDimension: maxDimension,
            position: adjustedEnd,
            type: warningType === 'WIDTH' ? 'RIGHT' : 'BOTTOM',
        });
        adjustedEnd = maxDimension;
    }
    return [adjustedStart, adjustedEnd];
}
function handleIOSBezelCorners(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var normalizedDeviceName, isSupported, isIosBezelError, _c, topImageName, bottomImageName, topImage, bottomImage, topBase64Image, _d, bottomBase64Image, _e, _f, _g, _h, _j;
        var addIOSBezelCorners = _b.addIOSBezelCorners, ctx = _b.ctx, deviceName = _b.deviceName, devicePixelRatio = _b.devicePixelRatio, height = _b.height, isLandscape = _b.isLandscape, width = _b.width;
        return __generator(this, function (_k) {
            switch (_k.label) {
                case 0:
                    normalizedDeviceName = deviceName
                        .toLowerCase()
                        .replace(/([^A-Za-z0-9]|simulator|inch|(\d(st|nd|rd|th)) generation)/gi, '');
                    isSupported = (normalizedDeviceName.includes('iphone') && constants_js_1.supportedIosBezelDevices.includes(normalizedDeviceName)) ||
                        (normalizedDeviceName.includes('ipad') &&
                            constants_js_1.supportedIosBezelDevices.includes(normalizedDeviceName) &&
                            (width / devicePixelRatio >= 1133 || height / devicePixelRatio >= 1133));
                    isIosBezelError = false;
                    if (!(addIOSBezelCorners && isSupported)) return [3, 10];
                    _c = (0, utils_js_1.getIosBezelImageNames)(normalizedDeviceName), topImageName = _c.topImageName, bottomImageName = _c.bottomImageName;
                    if (!(topImageName && bottomImageName)) return [3, 9];
                    topImage = (0, fs_extra_1.readFileSync)((0, node_path_1.join)(__dirname, '..', '..', 'assets', 'ios', "".concat(topImageName, ".png"))).toString('base64');
                    bottomImage = (0, fs_extra_1.readFileSync)((0, node_path_1.join)(__dirname, '..', '..', 'assets', 'ios', "".concat(bottomImageName, ".png"))).toString('base64');
                    if (!isLandscape) return [3, 2];
                    return [4, rotateBase64Image({
                            base64Image: topImage,
                            degrees: -90,
                            newHeight: (0, utils_js_1.getScreenshotSize)(topImage).width,
                            newWidth: (0, utils_js_1.getScreenshotSize)(topImage).height,
                        })];
                case 1:
                    _d = _k.sent();
                    return [3, 3];
                case 2:
                    _d = topImage;
                    _k.label = 3;
                case 3:
                    topBase64Image = _d;
                    if (!isLandscape) return [3, 5];
                    return [4, rotateBase64Image({
                            base64Image: bottomImage,
                            degrees: -90,
                            newHeight: (0, utils_js_1.getScreenshotSize)(topImage).width,
                            newWidth: (0, utils_js_1.getScreenshotSize)(topImage).height,
                        })];
                case 4:
                    _e = _k.sent();
                    return [3, 6];
                case 5:
                    _e = bottomImage;
                    _k.label = 6;
                case 6:
                    bottomBase64Image = _e;
                    _g = (_f = ctx).drawImage;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(topBase64Image))];
                case 7:
                    _g.apply(_f, [_k.sent(), 0, 0]);
                    _j = (_h = ctx).drawImage;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(bottomBase64Image))];
                case 8:
                    _j.apply(_h, [_k.sent(), isLandscape ? width - (0, utils_js_1.getScreenshotSize)(bottomImage).height : 0,
                        isLandscape ? 0 : height - (0, utils_js_1.getScreenshotSize)(bottomImage).height]);
                    return [3, 10];
                case 9:
                    isIosBezelError = true;
                    _k.label = 10;
                case 10:
                    if (addIOSBezelCorners && !isSupported) {
                        isIosBezelError = true;
                    }
                    if (isIosBezelError) {
                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\nWARNING:\nWe could not find the bezel corners for the device '".concat(deviceName, "'.\nThe normalized device name is '").concat(normalizedDeviceName, "'\nand couldn't be found in the supported devices:\n").concat(constants_js_1.supportedIosBezelDevices.join(', '), "\n#####################################################################################\n"));
                    }
                    return [2];
            }
        });
    });
}
function cropAndConvertToDataURL(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var canvas, ctx, image;
        var addIOSBezelCorners = _b.addIOSBezelCorners, base64Image = _b.base64Image, deviceName = _b.deviceName, devicePixelRatio = _b.devicePixelRatio, height = _b.height, isIOS = _b.isIOS, isLandscape = _b.isLandscape, sourceX = _b.sourceX, sourceY = _b.sourceY, width = _b.width;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    canvas = (0, canvas_1.createCanvas)(width, height);
                    ctx = canvas.getContext('2d');
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(base64Image))];
                case 1:
                    image = _c.sent();
                    ctx.drawImage(image, sourceX, sourceY, width, height, 0, 0, width, height);
                    if (!isIOS) return [3, 3];
                    return [4, handleIOSBezelCorners({ addIOSBezelCorners: addIOSBezelCorners, ctx: ctx, deviceName: deviceName, devicePixelRatio: devicePixelRatio, height: height, isLandscape: isLandscape, width: width })];
                case 2:
                    _c.sent();
                    _c.label = 3;
                case 3: return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
function makeCroppedBase64Image(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var newBase64Image, _c, screenshotHeight, screenshotWidth, _d, top, right, bottom, left, height, width, x, y, _e, sourceXStart, sourceXEnd, _f, sourceYStart, sourceYEnd;
        var addIOSBezelCorners = _b.addIOSBezelCorners, base64Image = _b.base64Image, deviceName = _b.deviceName, devicePixelRatio = _b.devicePixelRatio, _g = _b.isWebDriverElementScreenshot, isWebDriverElementScreenshot = _g === void 0 ? false : _g, isIOS = _b.isIOS, isLandscape = _b.isLandscape, logLevel = _b.logLevel, rectangles = _b.rectangles, _h = _b.resizeDimensions, resizeDimensions = _h === void 0 ? constants_js_1.DEFAULT_RESIZE_DIMENSIONS : _h;
        return __generator(this, function (_j) {
            switch (_j.label) {
                case 0: return [4, getRotatedImageIfNeeded({ isWebDriverElementScreenshot: isWebDriverElementScreenshot, isLandscape: isLandscape, base64Image: base64Image })];
                case 1:
                    newBase64Image = _j.sent();
                    _c = (0, utils_js_1.getScreenshotSize)(base64Image), screenshotHeight = _c.height, screenshotWidth = _c.width;
                    _d = __assign(__assign({}, constants_js_1.DEFAULT_RESIZE_DIMENSIONS), resizeDimensions), top = _d.top, right = _d.right, bottom = _d.bottom, left = _d.left;
                    height = rectangles.height, width = rectangles.width, x = rectangles.x, y = rectangles.y;
                    _e = getAdjustedAxis({
                        length: width,
                        logLevel: logLevel,
                        maxDimension: screenshotWidth,
                        paddingEnd: right,
                        paddingStart: left,
                        start: x,
                        warningType: 'WIDTH'
                    }), sourceXStart = _e[0], sourceXEnd = _e[1];
                    _f = getAdjustedAxis({
                        length: height,
                        logLevel: logLevel,
                        maxDimension: screenshotHeight,
                        paddingEnd: bottom,
                        paddingStart: top,
                        start: y,
                        warningType: 'HEIGHT',
                    }), sourceYStart = _f[0], sourceYEnd = _f[1];
                    return [2, cropAndConvertToDataURL({
                            addIOSBezelCorners: addIOSBezelCorners,
                            base64Image: newBase64Image,
                            deviceName: deviceName,
                            devicePixelRatio: devicePixelRatio,
                            height: sourceYEnd - sourceYStart,
                            isIOS: isIOS,
                            isLandscape: isLandscape,
                            sourceX: sourceXStart,
                            sourceY: sourceYStart,
                            width: sourceXEnd - sourceXStart,
                        })];
            }
        });
    });
}
exports.makeCroppedBase64Image = makeCroppedBase64Image;
function executeImageCompare(executor_1, options_1) {
    return __awaiter(this, arguments, void 0, function (executor, options, isViewPortScreenshot, isNativeContext) {
        var _a, ignoreRegions, devicePixelRatio, fileName, isAndroidNativeWebScreenshot, isAndroid, isHybridApp, isLandscape, logLevel, platformName, _b, actualFolder, autoSaveBaseline, baselineFolder, browserName, deviceName, diffFolder, isMobile, savePerInstance, diffFilePath, imageCompareOptions, createFolderOptions, actualFolderPath, baselineFolderPath, actualFilePath, baselineFilePath, resembleIgnoreDefaults, ignore, blockOut, webStatusAddressToolBarOptions, statusAddressToolBarOptions, _c, _d, _e, ignoredBoxes, compareOptions, data, rawMisMatchPercentage, reportMisMatchPercentage, isDifference, isDifferenceMessage, debugMessage, diffFolderPath, _f;
        if (isViewPortScreenshot === void 0) { isViewPortScreenshot = false; }
        if (isNativeContext === void 0) { isNativeContext = false; }
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    _a = options.ignoreRegions, ignoreRegions = _a === void 0 ? [] : _a, devicePixelRatio = options.devicePixelRatio, fileName = options.fileName, isAndroidNativeWebScreenshot = options.isAndroidNativeWebScreenshot, isAndroid = options.isAndroid, isHybridApp = options.isHybridApp, isLandscape = options.isLandscape, logLevel = options.logLevel, platformName = options.platformName;
                    _b = options.folderOptions, actualFolder = _b.actualFolder, autoSaveBaseline = _b.autoSaveBaseline, baselineFolder = _b.baselineFolder, browserName = _b.browserName, deviceName = _b.deviceName, diffFolder = _b.diffFolder, isMobile = _b.isMobile, savePerInstance = _b.savePerInstance;
                    imageCompareOptions = __assign(__assign({}, options.compareOptions.wic), options.compareOptions.method);
                    createFolderOptions = { browserName: browserName, deviceName: deviceName, isMobile: isMobile, savePerInstance: savePerInstance };
                    actualFolderPath = (0, utils_js_1.getAndCreatePath)(actualFolder, createFolderOptions);
                    baselineFolderPath = (0, utils_js_1.getAndCreatePath)(baselineFolder, createFolderOptions);
                    actualFilePath = (0, node_path_1.join)(actualFolderPath, fileName);
                    baselineFilePath = (0, node_path_1.join)(baselineFolderPath, fileName);
                    return [4, checkBaselineImageExists(actualFilePath, baselineFilePath, autoSaveBaseline, logLevel)];
                case 1:
                    _g.sent();
                    resembleIgnoreDefaults = ['alpha', 'antialiasing', 'colors', 'less', 'nothing'];
                    ignore = resembleIgnoreDefaults.filter(function (option) {
                        return Object.keys(imageCompareOptions).find(function (key) { return key.toLowerCase().includes(option) && imageCompareOptions[key]; });
                    });
                    blockOut = 'blockOut' in imageCompareOptions ? imageCompareOptions.blockOut || [] : [];
                    webStatusAddressToolBarOptions = [];
                    if (!!isNativeContext) return [3, 3];
                    statusAddressToolBarOptions = {
                        blockOutSideBar: imageCompareOptions.blockOutSideBar,
                        blockOutStatusBar: imageCompareOptions.blockOutStatusBar,
                        blockOutToolBar: imageCompareOptions.blockOutToolBar,
                        isHybridApp: isHybridApp,
                        isLandscape: isLandscape,
                        isMobile: isMobile,
                        isViewPortScreenshot: isViewPortScreenshot,
                        isAndroidNativeWebScreenshot: isAndroidNativeWebScreenshot,
                        platformName: platformName,
                    };
                    _d = (_c = webStatusAddressToolBarOptions.push).apply;
                    _e = [webStatusAddressToolBarOptions];
                    return [4, (0, rectangles_js_1.determineStatusAddressToolBarRectangles)(executor, statusAddressToolBarOptions)];
                case 2:
                    _d.apply(_c, _e.concat([(_g.sent()) || []]));
                    _g.label = 3;
                case 3:
                    ignoredBoxes = __spreadArray(__spreadArray(__spreadArray([], blockOut, true), ignoreRegions, true), webStatusAddressToolBarOptions, true).map(function (rectangles) {
                        return (0, utils_js_1.calculateDprData)({
                            bottom: rectangles.y + rectangles.height,
                            right: rectangles.x + rectangles.width,
                            left: rectangles.x,
                            top: rectangles.y,
                        }, isAndroid ? 1 : devicePixelRatio);
                    });
                    compareOptions = __assign(__assign({ ignore: ignore }, (ignoredBoxes.length > 0 ? { output: { ignoredBoxes: ignoredBoxes } } : {})), { scaleToSameSize: imageCompareOptions.scaleImagesToSameSize });
                    return [4, (0, compareImages_js_1.default)((0, fs_extra_1.readFileSync)(baselineFilePath), (0, fs_extra_1.readFileSync)(actualFilePath), compareOptions)];
                case 4:
                    data = _g.sent();
                    rawMisMatchPercentage = data.rawMisMatchPercentage;
                    reportMisMatchPercentage = imageCompareOptions.rawMisMatchPercentage
                        ? rawMisMatchPercentage
                        : Number(data.rawMisMatchPercentage.toFixed(3));
                    if (!(rawMisMatchPercentage > imageCompareOptions.saveAboveTolerance || logLevel === options_interfaces_1.LogLevel.debug)) return [3, 7];
                    isDifference = rawMisMatchPercentage > imageCompareOptions.saveAboveTolerance;
                    isDifferenceMessage = 'WARNING:\n There was a difference. Saved the difference to';
                    debugMessage = 'INFO:\n Debug mode is enabled. Saved the debug file to:';
                    diffFolderPath = (0, utils_js_1.getAndCreatePath)(diffFolder, createFolderOptions);
                    diffFilePath = (0, node_path_1.join)(diffFolderPath, fileName);
                    _f = saveBase64Image;
                    return [4, addBlockOuts(Buffer.from(data.getBuffer()).toString('base64'), ignoredBoxes)];
                case 5: return [4, _f.apply(void 0, [_g.sent(), diffFilePath])];
                case 6:
                    _g.sent();
                    if (logLevel === options_interfaces_1.LogLevel.debug || logLevel === options_interfaces_1.LogLevel.warn) {
                        console.log('\x1b[33m%s\x1b[0m', "\n#####################################################################################\n ".concat(isDifference ? isDifferenceMessage : debugMessage, "\n ").concat(diffFilePath, "\n#####################################################################################\n"));
                    }
                    _g.label = 7;
                case 7: return [2, imageCompareOptions.returnAllCompareData
                        ? {
                            fileName: fileName,
                            folders: __assign({ actual: actualFilePath, baseline: baselineFilePath }, (diffFilePath ? { diff: diffFilePath } : {})),
                            misMatchPercentage: reportMisMatchPercentage,
                        }
                        : reportMisMatchPercentage];
            }
        });
    });
}
exports.executeImageCompare = executeImageCompare;
function makeFullPageBase64Image(screenshotsData_1, _a) {
    return __awaiter(this, arguments, void 0, function (screenshotsData, _b) {
        var amountOfScreenshots, canvasHeight, canvasWidth, canvas, ctx, i, currentScreenshot, _c, screenshotHeight, screenshotWidth, isRotated, newBase64Image, _d, _e, canvasYPosition, imageHeight, imageWidth, imageXPosition, imageYPosition, image;
        var devicePixelRatio = _b.devicePixelRatio, isLandscape = _b.isLandscape;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    amountOfScreenshots = screenshotsData.data.length;
                    canvasHeight = screenshotsData.fullPageHeight, canvasWidth = screenshotsData.fullPageWidth;
                    canvas = (0, canvas_1.createCanvas)(canvasWidth, canvasHeight);
                    ctx = canvas.getContext('2d');
                    i = 0;
                    _f.label = 1;
                case 1:
                    if (!(i < amountOfScreenshots)) return [3, 7];
                    currentScreenshot = screenshotsData.data[i].screenshot;
                    _c = (0, utils_js_1.getScreenshotSize)(currentScreenshot, devicePixelRatio), screenshotHeight = _c.height, screenshotWidth = _c.width;
                    isRotated = isLandscape && screenshotHeight > screenshotWidth;
                    if (!isRotated) return [3, 3];
                    return [4, rotateBase64Image({
                            base64Image: currentScreenshot,
                            degrees: -90,
                            newHeight: screenshotWidth,
                            newWidth: screenshotHeight,
                        })];
                case 2:
                    _d = _f.sent();
                    return [3, 4];
                case 3:
                    _d = currentScreenshot;
                    _f.label = 4;
                case 4:
                    newBase64Image = _d;
                    _e = screenshotsData.data[i], canvasYPosition = _e.canvasYPosition, imageHeight = _e.imageHeight, imageWidth = _e.imageWidth, imageXPosition = _e.imageXPosition, imageYPosition = _e.imageYPosition;
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(newBase64Image))];
                case 5:
                    image = _f.sent();
                    ctx.drawImage(image, imageXPosition, imageYPosition, imageWidth, imageHeight, 0, canvasYPosition, imageWidth, imageHeight);
                    _f.label = 6;
                case 6:
                    i++;
                    return [3, 1];
                case 7: return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
exports.makeFullPageBase64Image = makeFullPageBase64Image;
function saveBase64Image(base64Image, filePath) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2, (0, fs_extra_1.outputFile)(filePath, base64Image, 'base64')];
        });
    });
}
exports.saveBase64Image = saveBase64Image;
function addBlockOuts(screenshot, ignoredBoxes) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, height, width, canvas, image, canvasContext;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = (0, utils_js_1.getScreenshotSize)(screenshot), height = _a.height, width = _a.width;
                    canvas = (0, canvas_1.createCanvas)(width, height);
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(screenshot))];
                case 1:
                    image = _b.sent();
                    canvasContext = canvas.getContext('2d');
                    canvasContext.drawImage(image, 0, 0, width, height, 0, 0, width, height);
                    ignoredBoxes.forEach(function (ignoredBox) {
                        var ignoredBoxWidth = ignoredBox.right, ignoredBoxHeight = ignoredBox.bottom, x = ignoredBox.left, y = ignoredBox.top;
                        var ignoreCanvas = (0, canvas_1.createCanvas)(ignoredBoxWidth - x, ignoredBoxHeight - y);
                        var ignoreContext = ignoreCanvas.getContext('2d');
                        ignoreContext.globalAlpha = 0.5;
                        ignoreContext.fillStyle = '#39aa56';
                        ignoreContext.fillRect(0, 0, ignoredBoxWidth - x, ignoredBoxHeight - y);
                        canvasContext.drawImage(ignoreCanvas, x, y);
                    });
                    return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
exports.addBlockOuts = addBlockOuts;
function rotateBase64Image(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var canvas, ctx, image;
        var base64Image = _b.base64Image, degrees = _b.degrees, newHeight = _b.newHeight, newWidth = _b.newWidth;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    canvas = (0, canvas_1.createCanvas)(newWidth, newHeight);
                    ctx = canvas.getContext('2d');
                    return [4, (0, canvas_1.loadImage)("data:image/png;base64,".concat(base64Image))];
                case 1:
                    image = _c.sent();
                    canvas.width = degrees % 180 === 0 ? image.width : image.height;
                    canvas.height = degrees % 180 === 0 ? image.height : image.width;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((degrees * Math.PI) / 180);
                    ctx.drawImage(image, image.width / -2, image.height / -2);
                    return [2, canvas.toDataURL().replace(/^data:image\/png;base64,/, '')];
            }
        });
    });
}
function takeResizedBase64Screenshot(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var awaitedElement, elementRegion, base64Image, resizedBase64Image;
        var element = _b.element, devicePixelRatio = _b.devicePixelRatio, isIOS = _b.isIOS, _c = _b.methods, getElementRect = _c.getElementRect, screenShot = _c.screenShot, resizeDimensions = _b.resizeDimensions;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4, element];
                case 1:
                    awaitedElement = _d.sent();
                    if (!(0, rectangles_js_1.isWdioElement)(awaitedElement)) {
                        console.log('awaitedElement = ', JSON.stringify(awaitedElement));
                    }
                    return [4, getElementRect(awaitedElement.elementId)];
                case 2:
                    elementRegion = _d.sent();
                    return [4, screenShot()];
                case 3:
                    base64Image = _d.sent();
                    return [4, makeCroppedBase64Image({
                            addIOSBezelCorners: false,
                            base64Image: base64Image,
                            deviceName: '',
                            devicePixelRatio: devicePixelRatio,
                            isIOS: isIOS,
                            isLandscape: false,
                            logLevel: 'debug',
                            rectangles: (0, utils_js_1.calculateDprData)({
                                height: elementRegion.height,
                                width: elementRegion.width,
                                x: elementRegion.x,
                                y: elementRegion.y,
                            }, isIOS ? devicePixelRatio : 1),
                            resizeDimensions: (0, utils_js_1.calculateDprData)(resizeDimensions, 1 / devicePixelRatio),
                        })];
                case 4:
                    resizedBase64Image = _d.sent();
                    return [2, resizedBase64Image];
            }
        });
    });
}
function takeBase64ElementScreenshot(_a) {
    return __awaiter(this, arguments, void 0, function (_b) {
        var shouldTakeResizedScreenshot, awaitedElement, error_1;
        var element = _b.element, devicePixelRatio = _b.devicePixelRatio, isIOS = _b.isIOS, _c = _b.methods, getElementRect = _c.getElementRect, screenShot = _c.screenShot, resizeDimensions = _b.resizeDimensions;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    shouldTakeResizedScreenshot = resizeDimensions !== constants_js_1.DEFAULT_RESIZE_DIMENSIONS;
                    if (!!shouldTakeResizedScreenshot) return [3, 5];
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 4, , 5]);
                    return [4, element];
                case 2:
                    awaitedElement = _d.sent();
                    if (!(0, rectangles_js_1.isWdioElement)(awaitedElement)) {
                        console.error(' takeBase64ElementScreenshot element is not a valid element because of ', JSON.stringify(awaitedElement));
                    }
                    return [4, awaitedElement.takeElementScreenshot(awaitedElement.elementId)];
                case 3: return [2, _d.sent()];
                case 4:
                    error_1 = _d.sent();
                    console.error('Error taking an element screenshot with the default `element.takeElementScreenshot(elementId)` method:', error_1, ' We will retry with a resized screenshot');
                    return [3, 5];
                case 5: return [4, takeResizedBase64Screenshot({
                        element: element,
                        devicePixelRatio: devicePixelRatio,
                        isIOS: isIOS,
                        methods: {
                            getElementRect: getElementRect,
                            screenShot: screenShot,
                        },
                        resizeDimensions: resizeDimensions,
                    })];
                case 6: return [2, _d.sent()];
            }
        });
    });
}
exports.takeBase64ElementScreenshot = takeBase64ElementScreenshot;
//# sourceMappingURL=images.js.map